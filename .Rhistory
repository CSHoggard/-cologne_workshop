gm.results$consensus
library('Binford')
library('binford')
Bethan <- LRB
head(Bethan)
View(Bethan)
Test <- LRBkey
View(Test)
install.packages("markdown")
install.packages("fdaPDE")
library('fdaPDE')
mesh<-create.MESH.2D(nodes=rbind(c(0, 0), c(0, 1), c(0.5, 0.5), c(1, 1), c(1, 0)),
segments=rbind(c(1, 2), c(2, 3), c(3, 4), c(4, 5), c(5, 1)), order=1)
## Plot it
plot(mesh)
## Creates the basis
FEMbasis = create.FEM.basis(mesh)
## Upload the Meuse data
data(MeuseData)
## Create a triangulation on the convex hull of these data,
## where each data location is a triangle vertex
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], order = 1)
## Plot the mesh
plot(mesh)
## Upload a domain boundary for these data
data(MeuseBorder)
## Create a constrained Delaunay triangulation with the provided boundary
## where each datalocation is a triangle vertex
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
## Plot the mesh
plot(mesh)
## Upload the Meuse data
data(MeuseData)
## Create a triangulation on the convex hull of these data,
## where each data location is a triangle vertex
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], order = 1)
## Plot the mesh
plot(mesh)
## Upload a domain boundary for these data
data(MeuseBorder)
## Create a constrained Delaunay triangulation with the provided boundary
## where each datalocation is a triangle vertex
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = 1)
## Plot the mesh
plot(mesh)
## Upload a triangular mesh and plot it
data("mesh.2D.rectangular")
plot(mesh.2D.rectangular)
## Create a linear Finite Element basis
FEMbasis = create.FEM.basis(mesh.2D.rectangular)
## Define a sinusoidal function as expansion of this basis and plot it
coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
FEM_object<- FEM(coeff, FEMbasis)
plot(FEM_object)
## Upload a triangular mesh and plot it
data("mesh.2D.rectangular")
plot(mesh.2D.rectangular)
## Create a linear Finite Element basis
FEMbasis = create.FEM.basis(mesh.2D.rectangular)
## Define a sinusoidal function as expansion of this basis and plot it
coeff <- sin(mesh.2D.rectangular$nodes[,1])*cos(mesh.2D.rectangular$nodes[,2])
FEM_object<- FEM(coeff, FEMbasis)
plot(FEM_object)
library(ggplot2)
library(dplyr)
#a hopalong attractor
#ggplot theme blank canvas
opt = theme(legend.position  = "none",
panel.background = element_rect(fill="white"),
axis.ticks       = element_blank(),
panel.grid       = element_blank(),
axis.title       = element_blank(),
axis.text        = element_blank())
#attractor function
createTrajectory <- function(n, x0, y0, a, b, c) {
#pre-initialize vectors of length n
x <- vector(mode = "numeric", length = n)
y <- vector(mode = "numeric", length = n)
#starting values
x[1] <- x0
y[1] <- y0
#fill vectors with values
for(i in 2:n) {
x[i] <- y[i-1]-1-sqrt(abs(b*x[i-1]-c))*sign(x[i-1]-1)
y[i] <- a-x[i-1]-1
}
#make dataframe
data.frame(x = x, y = y)
}
#constants
a=2
b=1
c=8
v=3
#calculate positions and plot
df=createTrajectory(3000000, 0, 0, a, b, c)
ggplot(df, aes(x, y)) + geom_point(color="#1E1E1E", shape=46, alpha=.05) + opt
ggplot(df, aes(x, y)) + geom_point(color="#1E1E1E", shape=46, alpha=.05) + opt
library(bibliometrix)
biblioshiny()
install.packages(c("ggforce", "ggplot2", "ggsignif", "markdown", "quantreg", "xml2"))
library(GUImorph, lib.loc = "C:/Program Files/R/R-3.6.1/library")
install.packages("Morpho")
detach("package:GUImorph", unload = TRUE)
library(GUImorph, lib.loc = "C:/Program Files/R/R-3.6.1/library")
install.packages("tcltk2")
library(GUImorph, lib.loc = "C:/Program Files/R/R-3.6.1/library")
GUImorph()
detach("package:GUImorph", unload = TRUE)
great.friends <- c("Christian", "Kaylea", "Cory", "Emma", "Bethan")
call(great.friends)
great.friends
knit_with_parameters('C:/Users/cshog/Dropbox/CHRISTIAN/Academic Work/Articles/Illustration Error - In Prep/submission/finalised_submission/Hoggard_et_al_2019.Rmd')
dataset <- "https://github.com/CSHoggard/-Morph2019/practical_two.csv""
dataset <- "https://github.com/CSHoggard/-Morph2019/practical_two.csv"
dataset <-  read.csv(dataset, header = T)
library(GUImorph, lib.loc = "C:/Program Files/R/R-3.6.1/library")
install.packages("Rphylip")
R.Version()
if(!require("Momocs")) install.packages('geomorph', repos='http://cran.us.r-project.org')
if(!require("tidyverse")) install.packages('tidyverse', repos='http://cran.us.r-project.org')
if(!require("ggtree")) install.packages('ggtree', repos='http://cran.us.r-project.org')
if(!require("ape")) install.packages('ape', repos='http://cran.us.r-project.org')
if(!require("Rphylip")) install.packages('Rphylip', repos='http://cran.us.r-project.org')
if(!require("tidytree")) install.packages('tidytree', repos='http://cran.us.r-project.org')
install.packages("ggsci")
library(ggsci)
scale_color_uchicago()
plot(scale_color_uchicago())
scale_color_uchicago()
p1 = ggplot(subset(diamonds, carat >= 2.2),
aes(x = table, y = price, colour = cut)) +
geom_point(alpha = 0.7) +
geom_smooth(method = "loess", alpha = 0.1, size = 1, span = 1) +
theme_bw()
library(ggplot2)
p1 = ggplot(subset(diamonds, carat >= 2.2),
aes(x = table, y = price, colour = cut)) +
geom_point(alpha = 0.7) +
geom_smooth(method = "loess", alpha = 0.1, size = 1, span = 1) +
theme_bw()
p1 + scale_color_uchicago()
scale_color_uchicago()
scale_color_uchicago
d <- scale_color_uchicago
d <- scale_color_uchicago()
d <- scale_color_uchicago
# install.packages("devtools")
devtools::install_github("ropenscilabs/vitae")
install.packages('tinytex')
install.packages("devtools")
devtools::install_github("ropenscilabs/vitae")
install.packages('tinytex')
tinytex::install_tinytex()
tinytex::tinytex_root()
tinytex::tinytex_root()
library(tinytex)
library(vitae)
remove.packages("vitae", lib="~/R/win-library/3.6")
install.packages("vitae")
library(vitae)
---
---
name: Rob J Hyndman
address: "Department of Econometrics & Business Statistics,\\tabularnewline Monash University, VIC 3800, Australia."
www: robjhyndman.com
phone: +61 3 9905 5141
email: "Rob.Hyndman@monash.edu"
twitter: robjhyndman
github: robjhyndman
date: "`r format(Sys.time(), '%B %Y')`"
headcolor: "000088"
output:
vitae::hyndman:
keep_tex: yes
header_includes:
- \ExecuteBibliographyOptions{useprefix=true}
- renewcommand{\bibfont}{\normalfont\fontsize{10}{12.4}\sffamily}
---
install.packages("digest")
install.packages("digest")
install.packages("digest")
install.packages("digest")
unlink('C:/Users/cshog/Desktop/test_cache', recursive = TRUE)
knit_with_parameters('C:/Users/cshog/Desktop/test.Rmd')
install.packages("digest")
install.packages("scholar")
remove.packages("yaml", lib="~/R/win-library/3.6")
install.packages("yaml")
unlink('C:/Users/cshog/Dropbox/CHRISTIAN/Academic Work/R_Projects/cv_csh/cv_csh/cv_csh_cache', recursive = TRUE)
install.packages(c("digest", "rlang"))
library(vitae)
install.packages("digest")
install.packages("digest")
install.packages("digest")
install.packages("digest")
unlink('Untitled/Untitled_cache', recursive = TRUE)
options(tinytex.verbose = TRUE)
install.packages("latexpdf")
library(latexpdf)
detach("package:latexpdf", unload = TRUE)
library(tinytex)
tinytex::install_tinytex()
unlink('C:/Users/cshog/Dropbox/CHRISTIAN/Academic Work/R_Projects/cv_csh/cv_csh/cv_csh/cv_csh_cache', recursive = TRUE)
detach("package:tinytex", unload = TRUE)
library(tinytex)
library(tinytex)
tinytex::tlmgr_install("ly1")
unlink('C:/Users/cshog/Dropbox/CHRISTIAN/Academic Work/R_Projects/cv_csh/cv_csh/cv_csh/cv_csh_cache', recursive = TRUE)
---
name: Christian Steven
surname: Hoggard
position: "Visiting Fellow"
address: "Department of Archaeology and Anthropology, University of Southampton"
phone: +44 7913 352688
www: sites.google.com/site/christianhoggard
email: "C.Hoggard@soton.ac.uk"
twitter: CSHoggard
github: CSHoggard
date: "`r format(Sys.time(), '%B %Y')`"
output:
vitae::latexcv:
theme: "modern"
---
if(!require("tidyverse")) install.packages('tidyverse', repos='http://cran.us.r-project.org')
if(!require("Momocs")) install.packages('geomorph', repos='http://cran.us.r-project.org')
if(!require("ggtree")) install.packages('ggtree', repos='http://cran.us.r-project.org')
if(!require("ape")) install.packages('ape', repos='http://cran.us.r-project.org')
if(!require("Rphylip")) install.packages('Rphylip', repos='http://cran.us.r-project.org')
if(!require("tidytree")) install.packages('tidytree', repos='http://cran.us.r-project.org')
if(!require("phytools")) install.packages('phytools', repos='http://cran.us.r-project.org')
if(!require("kohonen")) install.packages('kohonen', repos='http://cran.us.r-project.org')
if(!require("cowplot")) install.packages('cowplot', repos='http://cran.us.r-project.org')
backedpoints <- import_tps("TPS_BP_27_09_2019.tps", curves = TRUE) ### import .tps file
load("C:/Users/cshog/Dropbox/CHRISTIAN/Academic Work/GitHub/-Bornholm_Study/-Bornholm_Study.Rproj")
install.packages("countdown")
install.packages("xaringan")
install.packages("countdown")
if(!require("Momocs")) install.packages('Momocs', repos='http://cran.us.r-project.org')
if(!require("tidyverse")) install.packages('tidyverse', repos='http://cran.us.r-project.org')
if(!require("cowplot")) install.packages('cowplot', repos='http://cran.us.r-project.org')
if(!require("Momocs")) install.packages('Momocs', repos='http://cran.us.r-project.org')
if(!require("tidyverse")) install.packages('tidyverse', repos='http://cran.us.r-project.org')
if(!require("cowplot")) install.packages('cowplot', repos='http://cran.us.r-project.org')
install("ggtree")
library(geomorph)
library(Momocs)
library(ggtree)
library(tidyverse)
library(cowplot)
SK1 <- read.ply("skull_1.ply", ShowSpecimen = FALSE, addNormals = FALSE) ### import .PLY file
setwd("C:/Users/cshog/Dropbox/CHRISTIAN/Academic Work/GitHub/-cologne_workshop")
SK1 <- read.ply("skull_1.ply", ShowSpecimen = FALSE, addNormals = FALSE) ### import .PLY file
plot3d(SK1) ### plots the 3d mesh model
SK1$material
SK1$primitivetype
buildtemplate(SK1, 23, 200) ### build a template using the first .PLY file (23 landmarks, 200 surface semilandmarks)
SK1 <- read.ply("skull_1.ply", ShowSpecimen = FALSE, addNormals = TRUE) ### import .PLY file
SK1$material$colour <- "gray"
SK1 <- read.ply("skull_1.ply", ShowSpecimen = FALSE, addNormals = TRUE) ### import .PLY file
SK1$material$colour <- "gray"
SK1$material$colour
plot3d(SK1) ### plots the 3d mesh model
SK1$material$colour <- "red"
plot3d(SK1) ### plots the 3d mesh model
plot3d(SK1, type = "shade") ### plots the 3d mesh model
plot3d(SK1, type = "wire") ### plots the 3d mesh model
plot3d(SK1, type = "dots") ### plots the 3d mesh model
plot3d(SK1, type = "dots", col = "gray") ### plots the 3d mesh model
plot3d(SK1, col = "gray") ### plots the 3d mesh model
plot3d(SK1, col = "yellow") ### plots the 3d mesh model
skull  <- readmulti.nts(c("SK1.nts","SK2.nts","SK3.nts","SK4.nts","SK5.nts","SK6.nts")) ### importing finished file
groups <- read.csv("skulls.csv", header=T, row.names=1) ### import the metadata
View(groups)
is.factor(groups$Sex) ### checks factor
is.factor(groups$Location) ### checks factor
is.character(groups$Code) ### checks character
groups$code <- as.character(groups$Code) ### convert to character
surfslide<-read.csv("surfslide.csv", header=TRUE) ### sliding surface semilandmarks (configuration)
View(surfslide)
surfslide<-as.matrix(surfslide) ### convert to matrix
tanged.points <- import_tps("tanged.tps") ### import the tps
tanged.data <- read.csv("tanged.csv", header = TRUE, row.names = 1) ### metadata
outline <- rbind(c(1,2),c(2,3),c(3,4),c(4,5),c(5,6),c(6,1)) ### outline linking
tanged.points <- Ldk(tanged.points$coo, fac = tanged.data, links = outline) ### convert to landmark file in Momocs (this procedure can also be done in Geomorph!)
inspect(tanged.points)
inspect(tanged.points, cex = 0.5)
inspect(tanged.points, cex = 1)
inspect(tanged.points, cex = 100)
panel(tanged.points, names = TRUE) ### visualisation
panel(tanged.points, names = TRUE, fac = "Site", cex.names = 0.3, points.pch = 16, points.cex = 0.5) ### stylistic changes
panel(tanged.points, names = TRUE, links = TRUE, fac = "Site", cex.names = 0.3, points.pch = 16, points.cex = 0.5) ### stylistic changes
panel(tanged.points, names = TRUE, fac = "Site", cex.names = 0.3, points.pch = 16, points.cex = 0.5) ### stylistic changes
library(GUImorph) ### load GUImorph
GUImorph() ### activate
gpatp <- fgProcrustes(tanged.points)
stack(gpatp, ldk_cex = 2,  title = "GPA: Tanged Points", meanshape = TRUE)
gpaskull <- gpagen(skull, Proj = TRUE, ProcD = TRUE, curves = NULL, surfaces = surfslide) ### generalised Procrustes Analysis
gpaskull ### calls the object
plot(gpaskull)
plot(gpaskull, links = TRUE)
plot(gpaskull, mean = TRUE)
plot(gpaskull, mean = TRUE, label = TRUE)
plot(gpaskull, links = surfslide)
ref <- mshape(gpaskull$coords) ### calculates the mean shape of all skulls
ref ### calls the object
ref <- as.matrix(ref)	### converts the object to a matrix
tps_grid(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_4, legend = FALSE, poly = FALSE, amp = 1, grid.size = 5)
tps_iso(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_4, shp = FALSE, amp = 1, grid.size = 5)
tps_raw(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_4, amp = 1, grid.size = 5)
tps_arr(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_5, shp = FALSE, amp = 1, grid.size = 5)
pcatp <- PCA(gpatp, fac = tanged.data) ### creation of the principal component class item
pcatp$x ### principal component scores
scree(pcatp) ### scree table
scree_plot(pcatp) ### scree plot
plot(pcatp) ### plots the PCA graphic
plot(pcatp, cex = 1.5, fac = "Site", grid = FALSE, palette = col_autumn, chull.filled.alpha = 0.6, title = "Principal Component Analysis (PC1 vs. PC2)") ### customise the PCA graphic
pcasex <- plotTangentSpace(gpaskull$coords, axis1 = 1, axis2 = 2, warpgrids = TRUE, groups = groups$Sex, verbose = TRUE, label=groups$Code) ### principal component analysis
summary(pcasex) ### pca summary
pcasex$pc.shapes ### output (shape coordinates of the extreme ends of all PC axes)
pcasex$pc.shapes$PC1max ### e.g. PC1 max
pcasex$rotation ### rotation values
plotRefToTarget(ref, pcasex$pc.shapes$PC1max, method= "vector") ### shape change from mean shape (ref) to max PC1 (as vector)
plotRefToTarget(ref, pcasex$pc.shapes$PC1max, method= "points") ### shape change from mean shape (ref) to max PC1 (as vector)
pcalocation <- plotTangentSpace(skullgpa$coords, axis1 = 1, axis2 = 2, warpgrids = TRUE, groups = groups$Location, verbose = TRUE, label=groups$Code) ### principal component analysis
pcalocation <- plotTangentSpace(gpaskull$coords, axis1 = 1, axis2 = 2, warpgrids = TRUE, groups = groups$Location, verbose = TRUE, label=groups$Code) ### principal component analysis
summary(pcalocation) ### pca summary
pcalocation$pc.shapes ### output (shape coordinates of the extreme ends of all PC axes)
pcalocation$pc.shapes$PC1max ### e.g. PC1 max
pcalocation$rotation ### rotation values
ldatp <- LDA(pcatp, fac = "Site") ### create the LDA file
ldatp ### call the LDA item
plot(ldatp)
MANOVA(pcatp, fac = "Site", test = "Hotelling")
lmspecimensex <- procD.lm(two.d.array(gpaskull$coords) ~ groups$Sex, iter=99) ### Procrustes ANOVA (shape vs. sex)
lmspecimensex$aov.table ### anova table (summary)
lmspecimensex$call ### calls the code used
lmspecimensex$QR ### QR decompositions
lmspecimensex$fitted ### the fitted values
lmspecimensex$residuals ### the residuals (observed responses)
lmspecimensex$data ### the data frame for the model
lmspecimenlocation <- procD.lm(two.d.array(gpaskull$coords) ~ groups$Location, iter=99) ### Procrustes ANOVA (shape vs. location)
lmspecimenlocation$aov.table ### anova table (summary)
lmspecimenlocation$call ### calls the code used
lmspecimenlocation$QR ### QR decompositions
lmspecimenlocation$fitted ### the fitted values
lmspecimenlocation$residuals ### the residuals (observed responses)
lmspecimenlocation$data ### the data frame for the model
tpms <- mshapes(gpatp, FUN = mean, "Site") ### change FUN for median
panel(Ldk(tpms$Coe), names = TRUE, cex.names = 0.75, points.pch = 16, points.cex = 1.5)
cluster <- CLUST(pcatp, fac = "Site", type = "phylogram", dist_method = "euclidean", hclust_method = "complete") ### hierarchical clustering (complete)
cluster <- CLUST(pcatp, fac = "Site", type = "fan", dist_method = "euclidean", hclust_method = "complete") ### hierarchical clustering (complete)
ggtree(cluster, layout="rectangular") + geom_nodepoint() + geom_tiplab(hjust = -0.1) + xlim(0,0.03)
handaxe <- import_tps("handaxe.tps", curves = TRUE) ### .tps file with the outline data
handaxe.data <- read.csv("handaxe.csv", header = T, row.names = 1) ### handaxe dataset
View(handaxe.data)
handaxe.data$MIS = factor(handaxe.data$MIS, c("MIS 13", "MIS 11", "MIS 9", "MIS 7", "MIS 4/3")) ### reorder factor according to Marine Isotope Stage (MIS)
handaxe.data$Context = factor(handaxe.data$Context, c("Warren Hill", "Boxgrove", "Bowman's Lodge", "Elveden", "Swanscombe", "Broom", "Furze Platt", "Cuxton", "Pontnewydd", "Lynford")) ### reorder factor according to context
summary(handaxe.data$MIS) ### count data for the different MISs
summary(handaxe.data$Context) ### count data for the different archaeological contexts
outlinefile <- Out(handaxe$coo, fac = handaxe.data) ### creation of an outline file with the database supplying metadata
outlinefile ### call the outline file
panel(outlinefile) ### panel all examples
panel(outlinefile, fac = "MIS") ### panel coloured by MIS stages
panel(outlinefile, fac = "Context") ### panel coloured by context
outlinefile <- coo_close(outlinefile) ### ensure all outlines are closed
outlinefile <- coo_center(outlinefile) ### centre outlines to a common centroid (0,0)
outlinefile <- coo_scale(outlinefile) ### scale outlines to a common centroid size
2 + 2
Florian <- 2 + 2
Florian
2 + 2
2 + 2
2 + 2
setwd("C:/Users/cshog/Dropbox/CHRISTIAN/Academic Work/GitHub/-cologne_workshop")
library(beepr)
beep
beep()
beep(sound = 8)
if(!require("Momocs")) install.packages('Momocs', repos='http://cran.us.r-project.org')
if(!require("tidyverse")) install.packages('tidyverse', repos='http://cran.us.r-project.org')
install.packages("devtools")
library('GUImorph')
data("RBGlass1")
data <- data("RBGlass1")
data("RBGlass1")
rm(data)
data(RBGlass1)
handaxe <- read.csv("Handaxe.csv")
View(handaxe)
View(handaxe)
handaxe <- read.csv("Handaxe.csv", row.names = 1)
View(handaxe)
handaxe$Length
handaxe$Width
sd(handaxe$Width)
mean(handaxe$Width)
detach("package:tidyverse", unload = TRUE)
library(tidyverse)
ggplot(handaxe, aes(Length, Width))
ggplot(handaxe, aes(Length, Width)) + geom_point()
detach("package:ggtree", unload = TRUE)
ggsave("Graphic.tiff", dpi = 400, height = 160, width = 160, units = "mm")
ggplot(handaxe, aes(Length, Width)) + geom_point(aes(colour = MIS))
ggplot(handaxe, aes(Length, Width)) + geom_point(aes(colour = MIS)) + labs(x = "Length (mm)", y = "Width (mm)") + theme_minimal()
ggplot(handaxe, aes(Length, Width)) + geom_point(aes(colour = MIS)) + labs(x = "Length (mm)", y = "Width (mm)") + theme_minimal() + scale_color_manual(values = c("("#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00"))
ggplot(handaxe, aes(Length, Width)) + geom_point(aes(colour = MIS)) + labs(x = "Length (mm)", y = "Width (mm)") + theme_minimal() + scale_color_manual(values = c(#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00"))
ggplot(handaxe, aes(Length, Width)) + geom_point(aes(colour = MIS)) + labs(x = "Length (mm)", y = "Width (mm)") + theme_minimal() + scale_color_manual(values = c("#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00"))
ggplot(handaxe, aes(Length, Width)) + geom_point() + labs(x = "Length (mm)", y = "Width (mm)")
ggplot(handaxe, aes(Length, Width)) + geom_point() + labs(x = "Length (mm)", y = "Width (mm)") + theme_minimal()
ggplot(handaxe, aes(Length, Width)) + geom_point() + labs(x = "Length (mm)", y = "Width (mm)") + theme_gray()
ggplot(handaxe, aes(Length, Width)) + geom_point(aes(colour = MIS)) + labs(x = "Length (mm)", y = "Width (mm)") + theme_gray()
ggplot(handaxe, aes(Length, Width)) + geom_point(aes(colour = MIS)) + labs(x = "Length (mm)", y = "Width (mm)") + theme_gray() + scale_color_manual(values = c("#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00"))
if(!require("Momocs")) install.packages('Momocs', repos='http://cran.us.r-project.org')
if(!require("tidyverse")) install.packages('tidyverse', repos='http://cran.us.r-project.org')
if(!require("cowplot")) install.packages('cowplot', repos='http://cran.us.r-project.org')
library(geomorph)
library(Momocs)
library(ggtree)
library(tidyverse)
library(cowplot)
SK1 <- read.ply("skull_1.ply", ShowSpecimen = FALSE, addNormals = TRUE) ### import .PLY file
plot3d(SK1, col = "yellow") ### plots the 3d mesh model (colour is optional)
buildtemplate(SK1, 23, 200) ### build a template using the first .PLY file (23 landmarks, 200 surface semilandmarks)
skull  <- readmulti.nts(c("SK1.nts","SK2.nts","SK3.nts","SK4.nts","SK5.nts","SK6.nts")) ### importing finished file
groups <- read.csv("skulls.csv", header=T, row.names=1) ### import the metadata
View(groups)
is.factor(groups$Sex) ### checks factor
is.factor(groups$Location) ### checks factor
is.character(groups$Code) ### checks character
groups$code <- as.character(groups$Code) ### convert to character
is.character(groups$Code) ### checks character
groups$code <- as.character(groups$Code) ### convert to character
groups$Code <- as.character(groups$Code) ### convert to character
is.character(groups$Code) ### checks character
surfslide<-read.csv("surfslide.csv", header=TRUE) ### sliding surface semilandmarks (configuration)
surfslide<-as.matrix(surfslide) ### convert to matrix
tanged.points <- import_tps("tanged.tps") ### import the tps
tanged.data <- read.csv("tanged.csv", header = TRUE, row.names = 1) ### metadata
outline <- rbind(c(1,2),c(2,3),c(3,4),c(4,5),c(5,6),c(6,1)) ### outline linking
tanged.points <- Ldk(tanged.points$coo, fac = tanged.data, links = outline) ### convert to landmark file in Momocs (this procedure can also be done in Geomorph!)
inspect(tanged.points)
panel(tanged.points, names = TRUE) ### visualisation
panel(tanged.points, names = TRUE, fac = "Site", cex.names = 0.3, points.pch = 16, points.cex = 0.5) ### stylistic changes
library(GUImorph) ### load GUImorph
GUImorph() ### activate
GUImorph() ### activate
panel(tanged.points, names = TRUE, fac = "Site", cex.names = 1, points.pch = 16, points.cex = 0.5) ### stylistic changes
panel(tanged.points, names = TRUE) ### visualisation
stack(panel)
gpatp <- fgProcrustes(tanged.points)
stack(gpatp, ldk_cex = 2,  title = "GPA: Tanged Points", meanshape = TRUE)
gpaskull <- gpagen(skull, Proj = TRUE, ProcD = TRUE, curves = NULL, surfaces = surfslide) ### generalised Procrustes Analysis
gpaskull ### calls the object
plot(gpaskull)
ref <- mshape(gpaskull$coords) ### calculates the mean shape of all skulls
ref ### calls the object
ref <- as.matrix(ref)	### converts the object to a matrix
tps_grid(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_4, legend = FALSE, poly = FALSE, amp = 1, grid.size = 5)
tps_iso(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_4, shp = FALSE, amp = 1, grid.size = 5)
tps_raw(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_4, amp = 1, grid.size = 5)
tps_arr(gpatp$coo$Ellensbanke_1, gpatp$coo$Eskebjerg_1_5, shp = FALSE, amp = 1, grid.size = 5)
pcatp <- PCA(gpatp, fac = tanged.data) ### creation of the principal component class item
pcatp$x ### principal component scores
scree(pcatp) ### scree table
scree_plot(pcatp) ### scree plot
plot(pcatp) ### plots the PCA graphic
plot(pcatp, cex = 1.5, fac = "Site", grid = FALSE, palette = col_autumn, chull.filled.alpha = 0.6, title = "Principal Component Analysis (PC1 vs. PC2)") ### customise the PCA graphic
plot(pcatp, xax = 1, yax = 3, cex = 1.5, fac = "Site", grid = FALSE, palette = col_autumn, chull.filled.alpha = 0.6, title = "Principal Component Analysis (PC1 vs. PC2)") ### customise the PCA graphic
plot(pcatp, xax = 2, yax = 3, cex = 1.5, fac = "Site", grid = FALSE, palette = col_autumn, chull.filled.alpha = 0.6, title = "Principal Component Analysis (PC1 vs. PC2)") ### customise the PCA graphic
plot(pcatp, xax = 2, yax = 5, cex = 1.5, fac = "Site", grid = FALSE, palette = col_autumn, chull.filled.alpha = 0.6, title = "Principal Component Analysis (PC1 vs. PC2)") ### customise the PCA graphic
pcasex <- plotTangentSpace(gpaskull$coords, axis1 = 1, axis2 = 2, warpgrids = TRUE, groups = groups$Sex, verbose = TRUE, label=groups$Code) ### principal component analysis
summary(pcasex) ### pca summary
pcasex$pc.shapes ### output (shape coordinates of the extreme ends of all PC axes)
pcasex$pc.shapes$PC1max ### e.g. PC1 max
pcasex$rotation ### rotation values
plotRefToTarget(ref, pcasex$pc.shapes$PC1max, method= "points") ### shape change from mean shape (ref) to max PC1 (as vector)
plotRefToTarget(ref, pcasex$pc.shapes$PC1max, method= "points") ### shape change from mean shape (ref) to max PC1 (as vector)
database <- as_df(pcatp$x)
database <- as_df(pcatp)
ggplot(database, aes(PC1, PC2)) + geom_point()
pcalocation <- plotTangentSpace(gpaskull$coords, axis1 = 1, axis2 = 2, warpgrids = TRUE, groups = groups$Location, verbose = TRUE, label=groups$Code) ### principal component analysis
summary(pcalocation) ### pca summary
pcalocation$pc.shapes ### output (shape coordinates of the extreme ends of all PC axes)
ldatp <- LDA(pcatp, fac = "Site") ### create the LDA file
ldatp ### call the LDA item
plot(ldatp)
plot(ldatp)
MANOVA(pcatp, fac = "Site", test = "Hotelling")
lmspecimensex <- procD.lm(two.d.array(gpaskull$coords) ~ groups$Sex, iter=99) ### Procrustes ANOVA (shape vs. sex)
lmspecimensex$aov.table ### anova table (summary)
lmspecimensex$call ### calls the code used
lmspecimensex$QR ### QR decompositions
lmspecimensex$fitted ### the fitted values
lmspecimensex$residuals ### the residuals (observed responses)
lmspecimenlocation <- procD.lm(two.d.array(gpaskull$coords) ~ groups$Location, iter=99) ### Procrustes ANOVA (shape vs. location)
lmspecimenlocation$aov.table ### anova table (summary)
lmspecimenlocation$call ### calls the code used
lmspecimenlocation$QR ### QR decompositions
lmspecimenlocation$fitted ### the fitted values
lmspecimenlocation$residuals ### the residuals (observed responses)
lmspecimenlocation$data ### the data frame for the model
tpms <- mshapes(gpatp, FUN = mean, "Site") ### change FUN for median
panel(Ldk(tpms$Coe), names = TRUE, cex.names = 0.75, points.pch = 16, points.cex = 1.5)
tpms <- mshapes(gpatp, FUN = median, "Site") ### change FUN for median
panel(Ldk(tpms$Coe), names = TRUE, cex.names = 0.75, points.pch = 16, points.cex = 1.5)
cluster <- CLUST(pcatp, fac = "Site", type = "phylogram", dist_method = "euclidean", hclust_method = "complete") ### hierarchical clustering (complete)
cluster <- CLUST(pcatp, fac = "Site", type = "fan", dist_method = "euclidean", hclust_method = "complete") ### hierarchical clustering (complete)
KMEANS(pcatp)
KMEANS(pcatp, centers = 3)
KMEANS(pcatp, centers = 5)
KMEANS(pcatp, centers = 4)
